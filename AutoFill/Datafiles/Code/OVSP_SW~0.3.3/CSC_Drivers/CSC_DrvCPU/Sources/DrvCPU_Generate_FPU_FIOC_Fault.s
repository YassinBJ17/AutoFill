;-------------------------------------------------------------------------------
;                        SAFRAN Electronics & Defense
;                    Reproduction and disclosure forbidden.
;-------------------------------------------------------------------------------
; DESCRIPTION : DrvCPU_Generate_FPU_FIOC : To generate Invalid Operation fault 
;               for built-in tests
;-------------------------------------------------------------------------------

   .file "DrvCPU_Generate_FPU_FIOC.s"

;------------ include interface: -----------------------------------------------
; None

;------------ local objects: ---------------------------------------------------
   .set C_INF_POS, 0x7F800000
   .set C_INF_NEG, 0xFF800000
   .set C_NAN, 0x7FFFFFFF
   .set C_ONE_FLOAT, 0x3F800000


;------------ function bodies: -------------------------------------------------
   .text
   .global DrvCPU_Generate_FPU_FIOC
   .type DrvCPU_Generate_FPU_FIOC, $function

; DrvCPU_Generate_FPU_FIOC : To generate Invalid Operation fault 
;                            for built-in tests
;   Inputs: None
;   Outputs: None
;   Function return: r0, the number of invalid operations generated by the function
;   Pre-condition: None
;

DrvCPU_Generate_FPU_FIOC:
   ; C prototype:
      ; uint32_t DrvCPU_Generate_FPU_FIOC (void)
   
   push {r4-r11, r14}

   movs  r4,0
   
   ; Each step should raise a FPU Interrupt 

   ; *********************************************** 
   ; FIOCE: FPU Invalid Operation Interrupt trigger  
   ; *********************************************** 
   
   ;----------  1/ test invalidity by testing "+" operator commutativity with illicit operations  ----------

   ; (+INF) + (-INF) 
   PBIT_CORE_FPU_TEST_INV_OP_1:
      vldr.f32 s0, =C_INF_POS
      vldr.f32 s1, =C_INF_NEG

      add   r4,r4, #0x1

      vadd.f32 s0,s0,s1
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose registers s0 and s1 is operated in the IRQ handler. 
      ; Afterwards, we compare the values of s0 and s1 towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s1
      beq PBIT_CORE_FPU_TEST_INV_OP_2


   ; (-INF) + (+INF) 
   PBIT_CORE_FPU_TEST_INV_OP_2:
      vldr.f32 s0, =C_INF_NEG

      add   r4,r4, #0x1

      vldr.f32 s1, =C_INF_POS
      vadd.f32 s0,s0,s1
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose registers s0 and s1 is operated in the IRQ handler. 
      ; Afterwards, we compare the values of s0 and s1 towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s1 
      beq PBIT_CORE_FPU_TEST_INV_OP_3

   ;----------  2/ test invalidity by testing comparison operand with illicit operations  ----------

   ; NAN cmp 1.0 ? 
   PBIT_CORE_FPU_TEST_INV_OP_3:
      vldr.f32 s0, =C_NAN

      add   r4,r4, #0x1

      vldr.f32 s1, =C_ONE_FLOAT
      vcmpe.f32 s0,s1
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose registers s0 and s1 is operated in the IRQ handler. 
      ; Afterwards, we compare the values of s0 and s1 towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s1 
      beq PBIT_CORE_FPU_TEST_INV_OP_4


   ;----------  3/ test invalidity by testing "-" operator with illicit operations  ----------

   ; (+INF) - (+INF) 
   PBIT_CORE_FPU_TEST_INV_OP_4:
      vldr.f32 s0, =C_INF_POS
      add   r4,r4, #0x1

      vsub.f32 s0,s0,s0
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose registers s0 and s1 is operated in the IRQ handler. 
      ; Afterwards, we compare the values of s0 and s1 towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s1 
      beq PBIT_CORE_FPU_TEST_INV_OP_5


   ; (-INF) - (-INF) 
   PBIT_CORE_FPU_TEST_INV_OP_5:
      vldr.f32 s0, =C_INF_NEG

      add   r4,r4, #0x1

      vsub.f32 s0,s0,s0 
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_6


   ;----------  4/ test invalidity by testing "x" operator commutativity with illicit operations  ----------

   ; Zero * (+INF) 
   PBIT_CORE_FPU_TEST_INV_OP_6:
      vldr.f32 s0, =C_INF_NEG

      add   r4,r4, #0x1

      vmul.f32 s0,s18,s0
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_7

   ; Zero * (-INF) 
   PBIT_CORE_FPU_TEST_INV_OP_7:
      vldr.f32 s0, =C_INF_NEG

      add   r4,r4, #0x1

      vmul.f32 s0,s18,s0
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_8

   ; (+INF) * Zero 
   PBIT_CORE_FPU_TEST_INV_OP_8:
      vldr.f32 s0, =C_INF_POS

      add   r4,r4, #0x1

      vmul.f32 s0,s0,s18
      vmov.f32 s0, s31
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_9

   ; (-INF) * Zero 
   PBIT_CORE_FPU_TEST_INV_OP_9:
      vldr.f32 s0, =C_INF_NEG

      add   r4,r4, #0x1

      vmul.f32 s0,s0,s18
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_10



   ;----------  5/ test invalidity by testing "/" operator with illicit operations  ----------

  ; Zero / Zero 
   PBIT_CORE_FPU_TEST_INV_OP_10:

      add   r4,r4, #0x1

      vdiv.f32 s0,s16,s17
      vmov.f32 s0, s31
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_11

   
   ; (+INF)/(+INF) 
   PBIT_CORE_FPU_TEST_INV_OP_11:

      add   r4,r4, #0x1

      vldr.f32 s0, =C_INF_POS
      vdiv.f32 s0,s0,s0
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_12

   
   ; (+INF)/(-INF) 
   PBIT_CORE_FPU_TEST_INV_OP_12:

      add   r4,r4, #0x1

      vldr.f32 s0, =C_INF_POS
      vldr.f32 s1, =C_INF_NEG
      vdiv.f32 s0,s0,s1
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest 
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_13

   
   ; (-INF)/(+INF) 
   PBIT_CORE_FPU_TEST_INV_OP_13:

      add   r4,r4, #0x1

      vldr.f32 s0, =C_INF_NEG
      vldr.f32 s1, =C_INF_POS
      vdiv.f32 s0,s0,s1
      nop
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR

      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to prepare the next subtest       
      vcmp.f32 s0, s31 
      beq PBIT_CORE_FPU_TEST_INV_OP_14
   
   
   ; (-INF)/(-INF) 
   PBIT_CORE_FPU_TEST_INV_OP_14:

      add   r4,r4, #0x1

      vldr.f32 s0, =C_INF_NEG
      vdiv.f32 s0,s0,s0
      nop
      vmov.f32 s0, s31
      vmov.f32 s1, s31
      bl DrvCPU_Init_FPSCR_Reg
      bl DrvMCM_Reset_ISCR
      
      ; The flush of FPU Global purpose register s0 is operated in the IRQ handler. 
      ; Afterwards, we compare the value of s0 and s31 (which is 0.0) towards 0.0 to end the test 
      vcmp.f32 s0, s31

      nop
      mov r0, r4
      pop {r4-r11, r15}
      BX  r14

   .end
