#include "middleware/stack_ip/ETH_IP_private.h"
#include "middleware/ethernet/ETH_porting.h"
#include "libtools/memory/LIB_MEM_public.h"

 void ETH_IP_Reassembly (  const ts_CMN_IOSP_BUFFER * const p_Data,                                 uint32_t const p_offSetFragment,                                 uint32_t const p_flagFragment,                                 te_CMN_FLAG_VALIDITY* const p_validData ) {    const ts_ETH_IP_PacketHeader *   c_IPHeader_pt ;    uint32_t                         v_lastCellIndex;    uint32_t                         v_DataLen ;    uint32_t                         v_offset ;    c_IPHeader_pt = (const ts_ETH_IP_PacketHeader *)(p_Data->s_buffer );    ETH_IP_Reassembly_L_CheckTimeOut();    if (p_offSetFragment == 0UL)    {       if(  v_ETH_IP_ControlObj.s_RxFragment.s_IPFRx_status != e_ETH_IP_FRGMT_IN_PROG )       { #if (ETH_FEC != 0 )          LIB_MEM_CPY( v_ETH_IP_ControlObj.s_RxFragment.s_Packetbuff,                       p_Data->s_buffer,                       p_Data->s_buffer_size - K_ETH_IP_FCS_SIZE); #else          LIB_MEM_CPY( v_ETH_IP_ControlObj.s_RxFragment.s_Packetbuff,                                p_Data->s_buffer,                                p_Data->s_buffer_size); #endif          v_ETH_IP_ControlObj.s_RxFragment.s_IPFRx_status = e_ETH_IP_FRGMT_IN_PROG ; #if (ETH_FEC != 0 )          v_ETH_IP_ControlObj.s_RxFragment.s_dataLen = p_Data->s_buffer_size - K_ETH_IP_FCS_SIZE ; #else          v_ETH_IP_ControlObj.s_RxFragment.s_dataLen = p_Data->s_buffer_size ; #endif          v_ETH_IP_ControlObj.s_RxFragment.s_chrono.s_ongoing = 0UL ;          v_ETH_IP_ControlObj.s_RxFragment.s_chrono.s_end = (uint32_t)c_IPHeader_pt->s_IP_ip.s_IP_TimeToLive * (uint32_t)K_ETH_IP_SEC_TO_NS;          LIBT_TIME_Update( &v_ETH_IP_ControlObj.s_RxFragment.s_chrono ) ;          *p_validData = e_CMN_FLAG_VALID;       }       else       {          *p_validData = e_CMN_FLAG_NOT_VALID;       }    }    else    {       if (  v_ETH_IP_ControlObj.s_RxFragment.s_IPFRx_status == e_ETH_IP_FRGMT_IN_PROG )       {          *p_validData = ETH_IP_Reassembly_L_Check( c_IPHeader_pt ) ;          if (  *p_validData == e_CMN_FLAG_VALID )          { #if (ETH_FEC != 0 )             v_DataLen =  p_Data->s_buffer_size - K_ETH_IP_FCS_SIZE - (uint32_t)sizeof(ts_ETH_IP_PacketHeader) ; #else             v_DataLen =  p_Data->s_buffer_size - (uint32_t)sizeof(ts_ETH_IP_PacketHeader) ; #endif             v_offset = p_offSetFragment + (uint32_t)sizeof(ts_ETH_IP_PacketHeader);             v_lastCellIndex = p_offSetFragment + v_DataLen;             if ( v_lastCellIndex > INTEG_ETH_IP_SIZE_MAX_DATA_EXCHANGE )             {                v_ETH_IP_ControlObj.s_RxFragment.s_IPFRx_status = e_ETH_IP_FRGMT_INVALID ;             }             else             {                LIB_MEM_CPY( (v_ETH_IP_ControlObj.s_RxFragment.s_Packetbuff + v_offset),                             (int8_t*) (p_Data->s_buffer + sizeof(ts_ETH_IP_PacketHeader) ),                             v_DataLen );                if ( v_lastCellIndex > v_ETH_IP_ControlObj.s_RxFragment.s_dataLen )                {                   v_ETH_IP_ControlObj.s_RxFragment.s_dataLen =  v_lastCellIndex ;                }             }             if (p_flagFragment == 0ul)             {                v_ETH_IP_ControlObj.s_RxFragment.s_IPFRx_status = e_ETH_IP_FRGMT_FINISH ;                v_ETH_IP_ControlObj.s_RxFragment.s_dataLen = v_ETH_IP_ControlObj.s_RxFragment.s_dataLen + (uint32_t)sizeof(ts_ETH_IP_PacketHeader);             }          }       }       else       {          *p_validData = e_CMN_FLAG_NOT_VALID;       }    } }
